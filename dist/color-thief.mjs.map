{"version":3,"file":"color-thief.mjs","sources":["../src/color-thief.js"],"sourcesContent":["/*\n * Color Thief v2.2.0\n * by Lokesh Dhakar - http://www.lokeshdhakar.com\n *\n * Thanks\n * ------\n * Nick Rabinowitz - For creating quantize.js.\n * John Schulz - For clean up and optimization. @JFSIII\n * Nathan Spady - For adding drag and drop support to the demo page.\n *\n * License\n * -------\n * Copyright Lokesh Dhakar\n * Released under the MIT license\n * https://raw.githubusercontent.com/lokesh/color-thief/master/LICENSE\n *\n * @license\n */\n\n\n/*\n  CanvasImage Class\n  Class that wraps the html image element and canvas.\n  It also simplifies some of the canvas context manipulation\n  with a set of helper functions.\n*/\n\nvar CanvasImage = function (image) {\n    this.canvas  = document.createElement('canvas');\n    this.context = this.canvas.getContext('2d');\n\n    this.width  = this.canvas.width  = image.width;\n    this.height = this.canvas.height = image.height;\n\n    this.context.drawImage(image, 0, 0, this.width, this.height);\n};\n\nCanvasImage.prototype.getPixelCount = function () {\n    return this.width * this.height;\n};\n\nCanvasImage.prototype.getImageData = function () {\n    return this.context.getImageData(0, 0, this.width, this.height);\n};\n\nvar ColorThief = function () {};\n\n/*\n * getColor(sourceImage[, quality])\n * returns {r: num, g: num, b: num}\n *\n * Use the median cut algorithm provided by quantize.js to cluster similar\n * colors and return the base color from the largest cluster.\n *\n * Quality is an optional argument. It needs to be an integer. 1 is the highest quality settings.\n * 10 is the default. There is a trade-off between quality and speed. The bigger the number, the\n * faster a color will be returned but the greater the likelihood that it will not be the visually\n * most dominant color.\n *\n * */\nColorThief.prototype.getColor = function(sourceImage, quality) {\n    var palette       = this.getPalette(sourceImage, 5, quality);\n    var dominantColor = palette[0];\n    return dominantColor;\n};\n\n\n/*\n * getPalette(sourceImage[, colorCount, quality])\n * returns array[ {r: num, g: num, b: num}, {r: num, g: num, b: num}, ...]\n *\n * Use the median cut algorithm provided by quantize.js to cluster similar colors.\n *\n * colorCount determines the size of the palette; the number of colors returned. If not set, it\n * defaults to 10.\n *\n * BUGGY: Function does not always return the requested amount of colors. It can be +/- 2.\n *\n * quality is an optional argument. It needs to be an integer. 1 is the highest quality settings.\n * 10 is the default. There is a trade-off between quality and speed. The bigger the number, the\n * faster the palette generation but the greater the likelihood that colors will be missed.\n *\n *\n */\nColorThief.prototype.getPalette = function(sourceImage, colorCount, quality) {\n\n    if (typeof colorCount === 'undefined' || colorCount < 2 || colorCount > 256) {\n        colorCount = 10;\n    }\n    if (typeof quality === 'undefined' || quality < 1) {\n        quality = 10;\n    }\n\n    // Create custom CanvasImage object\n    var image      = new CanvasImage(sourceImage);\n    var imageData  = image.getImageData();\n    var pixels     = imageData.data;\n    var pixelCount = image.getPixelCount();\n\n    // Store the RGB values in an array format suitable for quantize function\n    var pixelArray = [];\n    for (var i = 0, offset, r, g, b, a; i < pixelCount; i = i + quality) {\n        offset = i * 4;\n        r = pixels[offset + 0];\n        g = pixels[offset + 1];\n        b = pixels[offset + 2];\n        a = pixels[offset + 3];\n        // If pixel is mostly opaque and not white\n        if (a >= 125) {\n            if (!(r > 250 && g > 250 && b > 250)) {\n                pixelArray.push([r, g, b]);\n            }\n        }\n    }\n\n    // Send array to quantize function which clusters values\n    // using median cut algorithm\n    var cmap    = MMCQ.quantize(pixelArray, colorCount);\n    var palette = cmap? cmap.palette() : null;\n\n    return palette;\n};\n\nColorThief.prototype.getColorFromUrl = function(imageUrl, callback, quality) {\n    let sourceImage = document.createElement(\"img\");\n    var thief = this;\n    sourceImage.addEventListener('load' , function(){\n        var palette = thief.getPalette(sourceImage, 5, quality);\n        var dominantColor = palette[0];\n        callback(dominantColor, imageUrl);\n    });\n    sourceImage.src = imageUrl\n};\n\n\nColorThief.prototype.getImageData = function(imageUrl, callback) {\n    let xhr = new XMLHttpRequest();\n    xhr.open('GET', imageUrl, true);\n    xhr.responseType = 'arraybuffer'\n    xhr.onload = function() {\n        if (this.status == 200) {\n            let uInt8Array = new Uint8Array(this.response)\n            i = uInt8Array.length\n            let binaryString = new Array(i);\n            for (var i = 0; i < uInt8Array.length; i++){\n                binaryString[i] = String.fromCharCode(uInt8Array[i])\n            }\n            let data = binaryString.join('')\n            let base64 = window.btoa(data)\n            callback (\"data:image/png;base64,\"+base64)\n        }\n    }\n    xhr.send();\n};\n\nColorThief.prototype.getColorAsync = function(imageUrl, callback, quality) {\n    var thief = this;\n    this.getImageData(imageUrl, function(imageData){\n        let sourceImage = document.createElement(\"img\");\n        sourceImage.addEventListener('load' , function(){\n            var palette = thief.getPalette(sourceImage, 5, quality);\n            var dominantColor = palette[0];\n            callback(dominantColor, this);\n        });\n        sourceImage.src = imageData;\n    });\n};\n\n\n\n/*!\n * quantize.js Copyright 2008 Nick Rabinowitz.\n * Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php\n * @license\n */\n\n// fill out a couple protovis dependencies\n/*!\n * Block below copied from Protovis: http://mbostock.github.com/protovis/\n * Copyright 2010 Stanford Visualization Group\n * Licensed under the BSD License: http://www.opensource.org/licenses/bsd-license.php\n * @license\n */\nif (!pv) {\n    var pv = {\n        map: function(array, f) {\n          var o = {};\n          return f ? array.map(function(d, i) { o.index = i; return f.call(o, d); }) : array.slice();\n        },\n        naturalOrder: function(a, b) {\n            return (a < b) ? -1 : ((a > b) ? 1 : 0);\n        },\n        sum: function(array, f) {\n          var o = {};\n          return array.reduce(f ? function(p, d, i) { o.index = i; return p + f.call(o, d); } : function(p, d) { return p + d; }, 0);\n        },\n        max: function(array, f) {\n          return Math.max.apply(null, f ? pv.map(array, f) : array);\n        }\n    };\n}\n\n\n\n/**\n * Basic Javascript port of the MMCQ (modified median cut quantization)\n * algorithm from the Leptonica library (http://www.leptonica.com/).\n * Returns a color map you can use to map original pixels to the reduced\n * palette. Still a work in progress.\n *\n * @author Nick Rabinowitz\n * @example\n\n// array of pixels as [R,G,B] arrays\nvar myPixels = [[190,197,190], [202,204,200], [207,214,210], [211,214,211], [205,207,207]\n                // etc\n                ];\nvar maxColors = 4;\n\nvar cmap = MMCQ.quantize(myPixels, maxColors);\nvar newPalette = cmap.palette();\nvar newPixels = myPixels.map(function(p) {\n    return cmap.map(p);\n});\n\n */\nvar MMCQ = (function() {\n    // private constants\n    var sigbits = 5;\n    var rshift = 8 - sigbits;\n    var maxIterations = 1000;\n    var fractByPopulations = 0.75;\n\n    // get reduced-space color index for a pixel\n    function getColorIndex(r, g, b) {\n        return (r << (2 * sigbits)) + (g << sigbits) + b;\n    }\n\n    // Simple priority queue\n    function PQueue(comparator) {\n        var contents = [];\n        var sorted = false;\n\n        function sort() {\n            contents.sort(comparator);\n            sorted = true;\n        }\n\n        return {\n            push: function(o) {\n                contents.push(o);\n                sorted = false;\n            },\n            peek: function(index) {\n                if (!sorted) sort();\n                if (index===undefined) index = contents.length - 1;\n                return contents[index];\n            },\n            pop: function() {\n                if (!sorted) sort();\n                return contents.pop();\n            },\n            size: function() {\n                return contents.length;\n            },\n            map: function(f) {\n                return contents.map(f);\n            },\n            debug: function() {\n                if (!sorted) sort();\n                return contents;\n            }\n        };\n    }\n\n    // 3d color space box\n    function VBox(r1, r2, g1, g2, b1, b2, histo) {\n        var vbox = this;\n        vbox.r1 = r1;\n        vbox.r2 = r2;\n        vbox.g1 = g1;\n        vbox.g2 = g2;\n        vbox.b1 = b1;\n        vbox.b2 = b2;\n        vbox.histo = histo;\n    }\n    VBox.prototype = {\n        volume: function(force) {\n            var vbox = this;\n            if (!vbox._volume || force) {\n                vbox._volume = ((vbox.r2 - vbox.r1 + 1) * (vbox.g2 - vbox.g1 + 1) * (vbox.b2 - vbox.b1 + 1));\n            }\n            return vbox._volume;\n        },\n        count: function(force) {\n            var vbox = this;\n            var histo = vbox.histo;\n            if (!vbox._count_set || force) {\n                var npix = 0;\n                var index; var i; var j; var k;\n                for (i = vbox.r1; i <= vbox.r2; i++) {\n                    for (j = vbox.g1; j <= vbox.g2; j++) {\n                        for (k = vbox.b1; k <= vbox.b2; k++) {\n                             index = getColorIndex(i,j,k);\n                             npix += (histo[index] || 0);\n                        }\n                    }\n                }\n                vbox._count = npix;\n                vbox._count_set = true;\n            }\n            return vbox._count;\n        },\n        copy: function() {\n            var vbox = this;\n            return new VBox(vbox.r1, vbox.r2, vbox.g1, vbox.g2, vbox.b1, vbox.b2, vbox.histo);\n        },\n        avg: function(force) {\n            var vbox = this;\n            var histo = vbox.histo;\n            if (!vbox._avg || force) {\n                var ntot = 0;\n                var mult = 1 << (8 - sigbits);\n                var rsum = 0;\n                var gsum = 0;\n                var bsum = 0;\n                var hval;\n                var i, j, k;\n                var histoindex;\n                for (i = vbox.r1; i <= vbox.r2; i++) {\n                    for (j = vbox.g1; j <= vbox.g2; j++) {\n                        for (k = vbox.b1; k <= vbox.b2; k++) {\n                             histoindex = getColorIndex(i,j,k);\n                             hval = histo[histoindex] || 0;\n                             ntot += hval;\n                             rsum += (hval * (i + 0.5) * mult);\n                             gsum += (hval * (j + 0.5) * mult);\n                             bsum += (hval * (k + 0.5) * mult);\n                        }\n                    }\n                }\n                if (ntot) {\n                    vbox._avg = [~~(rsum/ntot), ~~(gsum/ntot), ~~(bsum/ntot)];\n                } else {\n                    // console.log('empty box');\n                    vbox._avg = [\n                        ~~(mult * (vbox.r1 + vbox.r2 + 1) / 2),\n                        ~~(mult * (vbox.g1 + vbox.g2 + 1) / 2),\n                        ~~(mult * (vbox.b1 + vbox.b2 + 1) / 2)\n                    ];\n                }\n            }\n            return vbox._avg;\n        },\n        contains: function(pixel) {\n            var vbox = this;\n            var rval = pixel[0] >> rshift;\n            var gval = pixel[1] >> rshift;\n            var bval = pixel[2] >> rshift;\n            return (rval >= vbox.r1 && rval <= vbox.r2 &&\n                    gval >= vbox.g1 && gval <= vbox.g2 &&\n                    bval >= vbox.b1 && bval <= vbox.b2);\n        }\n    };\n\n    // Color map\n    function CMap() {\n        this.vboxes = new PQueue(function(a,b) {\n            return pv.naturalOrder(\n                a.vbox.count()*a.vbox.volume(),\n                b.vbox.count()*b.vbox.volume()\n            );\n        });\n    }\n    CMap.prototype = {\n        push: function(vbox) {\n            this.vboxes.push({\n                vbox: vbox,\n                color: vbox.avg()\n            });\n        },\n        palette: function() {\n            return this.vboxes.map(function(vb) { return vb.color; });\n        },\n        size: function() {\n            return this.vboxes.size();\n        },\n        map: function(color) {\n            var vboxes = this.vboxes;\n            for (var i=0; i<vboxes.size(); i++) {\n                if (vboxes.peek(i).vbox.contains(color)) {\n                    return vboxes.peek(i).color;\n                }\n            }\n            return this.nearest(color);\n        },\n        nearest: function(color) {\n            var vboxes = this.vboxes;\n            var d1;\n            var d2;\n            var pColor;\n            for (var i=0; i<vboxes.size(); i++) {\n                d2 = Math.sqrt(\n                    Math.pow(color[0] - vboxes.peek(i).color[0], 2) +\n                    Math.pow(color[1] - vboxes.peek(i).color[1], 2) +\n                    Math.pow(color[2] - vboxes.peek(i).color[2], 2)\n                );\n                if (d2 < d1 || d1 === undefined) {\n                    d1 = d2;\n                    pColor = vboxes.peek(i).color;\n                }\n            }\n            return pColor;\n        },\n        forcebw: function() {\n            // XXX: won't  work yet\n            var vboxes = this.vboxes;\n            vboxes.sort(function(a,b) { return pv.naturalOrder(pv.sum(a.color), pv.sum(b.color));});\n\n            // force darkest color to black if everything < 5\n            var lowest = vboxes[0].color;\n            if (lowest[0] < 5 && lowest[1] < 5 && lowest[2] < 5)\n                vboxes[0].color = [0,0,0];\n\n            // force lightest color to white if everything > 251\n            var idx = vboxes.length-1;\n            var highest = vboxes[idx].color;\n            if (highest[0] > 251 && highest[1] > 251 && highest[2] > 251)\n                vboxes[idx].color = [255,255,255];\n        }\n    };\n\n    // histo (1-d array, giving the number of pixels in\n    // each quantized region of color space), or null on error\n    function getHisto(pixels) {\n        var histosize = 1 << (3 * sigbits);\n        var histo = new Array(histosize);\n        var index; var rval; var gval; var bval;\n        pixels.forEach(function(pixel) {\n            rval = pixel[0] >> rshift;\n            gval = pixel[1] >> rshift;\n            bval = pixel[2] >> rshift;\n            index = getColorIndex(rval, gval, bval);\n            histo[index] = (histo[index] || 0) + 1;\n        });\n        return histo;\n    }\n\n    function vboxFromPixels(pixels, histo) {\n        var rmin=1000000; var rmax=0;\n        var gmin=1000000; var gmax=0;\n        var bmin=1000000; var bmax=0;\n        var rval; var gval; var bval;\n        // find min/max\n        pixels.forEach(function(pixel) {\n            rval = pixel[0] >> rshift;\n            gval = pixel[1] >> rshift;\n            bval = pixel[2] >> rshift;\n            if (rval < rmin) rmin = rval;\n            else if (rval > rmax) rmax = rval;\n            if (gval < gmin) gmin = gval;\n            else if (gval > gmax) gmax = gval;\n            if (bval < bmin) bmin = bval;\n            else if (bval > bmax)  bmax = bval;\n        });\n        return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);\n    }\n\n    function medianCutApply(histo, vbox) {\n        if (!vbox.count()) return;\n\n        var rw = vbox.r2 - vbox.r1 + 1;\n        var gw = vbox.g2 - vbox.g1 + 1;\n        var bw = vbox.b2 - vbox.b1 + 1;\n        var maxw = pv.max([rw, gw, bw]);\n        // only one pixel, no split\n        if (vbox.count() == 1) {\n            return [vbox.copy()];\n        }\n        /* Find the partial sum arrays along the selected axis. */\n        var total = 0;\n        var partialsum = [];\n        var lookaheadsum = [];\n        var i; var j; var k; var sum; var index;\n        if (maxw == rw) {\n            for (i = vbox.r1; i <= vbox.r2; i++) {\n                sum = 0;\n                for (j = vbox.g1; j <= vbox.g2; j++) {\n                    for (k = vbox.b1; k <= vbox.b2; k++) {\n                        index = getColorIndex(i,j,k);\n                        sum += (histo[index] || 0);\n                    }\n                }\n                total += sum;\n                partialsum[i] = total;\n            }\n        }\n        else if (maxw == gw) {\n            for (i = vbox.g1; i <= vbox.g2; i++) {\n                sum = 0;\n                for (j = vbox.r1; j <= vbox.r2; j++) {\n                    for (k = vbox.b1; k <= vbox.b2; k++) {\n                        index = getColorIndex(j,i,k);\n                        sum += (histo[index] || 0);\n                    }\n                }\n                total += sum;\n                partialsum[i] = total;\n            }\n        }\n        else {  /* maxw == bw */\n            for (i = vbox.b1; i <= vbox.b2; i++) {\n                sum = 0;\n                for (j = vbox.r1; j <= vbox.r2; j++) {\n                    for (k = vbox.g1; k <= vbox.g2; k++) {\n                        index = getColorIndex(j,k,i);\n                        sum += (histo[index] || 0);\n                    }\n                }\n                total += sum;\n                partialsum[i] = total;\n            }\n        }\n        partialsum.forEach(function(d,i) {\n            lookaheadsum[i] = total-d;\n        });\n        function doCut(color) {\n            var dim1 = color + '1';\n            var dim2 = color + '2';\n            var left; var right; var vbox1; var vbox2; var d2; var count2=0;\n            for (i = vbox[dim1]; i <= vbox[dim2]; i++) {\n                if (partialsum[i] > total / 2) {\n                    vbox1 = vbox.copy();\n                    vbox2 = vbox.copy();\n                    left = i - vbox[dim1];\n                    right = vbox[dim2] - i;\n                    if (left <= right)\n                        d2 = Math.min(vbox[dim2] - 1, ~~(i + right / 2));\n                    else d2 = Math.max(vbox[dim1], ~~(i - 1 - left / 2));\n                    // avoid 0-count boxes\n                    while (!partialsum[d2]) d2++;\n                    count2 = lookaheadsum[d2];\n                    while (!count2 && partialsum[d2-1]) count2 = lookaheadsum[--d2];\n                    // set dimensions\n                    vbox1[dim2] = d2;\n                    vbox2[dim1] = vbox1[dim2] + 1;\n//                    console.log('vbox counts:', vbox.count(), vbox1.count(), vbox2.count());\n                    return [vbox1, vbox2];\n                }\n            }\n\n        }\n        // determine the cut planes\n        return maxw == rw ? doCut('r') :\n            maxw == gw ? doCut('g') :\n            doCut('b');\n    }\n\n    function quantize(pixels, maxcolors) {\n        // short-circuit\n        if (!pixels.length || maxcolors < 2 || maxcolors > 256) {\n//            console.log('wrong number of maxcolors');\n            return false;\n        }\n\n        // XXX: check color content and convert to grayscale if insufficient\n\n        var histo = getHisto(pixels);\n        // histosize = 1 << (3 * sigbits);\n\n        // check that we aren't below maxcolors already\n        var nColors = 0;\n        histo.forEach(function() { nColors++; });\n        if (nColors <= maxcolors) {\n            // XXX: generate the new colors from the histo and return\n        }\n\n        // get the beginning vbox from the colors\n        var vbox = vboxFromPixels(pixels, histo);\n            var pq = new PQueue(function(a,b) { return pv.naturalOrder(a.count(), b.count()); });\n        pq.push(vbox);\n\n        // inner function to do the iteration\n        function iter(lh, target) {\n            var ncolors = 1;\n            var niters = 0;\n            var vbox;\n            while (niters < maxIterations) {\n                vbox = lh.pop();\n                if (!vbox.count())  { /* just put it back */\n                    lh.push(vbox);\n                    niters++;\n                    continue;\n                }\n                // do the cut\n                var vboxes = medianCutApply(histo, vbox);\n                    var vbox1 = vboxes[0];\n                    var vbox2 = vboxes[1];\n\n                if (!vbox1) {\n//                  console.log(\"vbox1 not defined; shouldn't happen!\");\n                    return;\n                }\n                lh.push(vbox1);\n                if (vbox2) {  /* vbox2 can be null */\n                    lh.push(vbox2);\n                    ncolors++;\n                }\n                if (ncolors >= target) return;\n                if (niters++ > maxIterations) {\n//                    console.log(\"infinite loop; perhaps too few pixels!\");\n                    return;\n                }\n            }\n        }\n\n        // first set of colors, sorted by population\n        iter(pq, fractByPopulations * maxcolors);\n\n        // Re-sort by the product of pixel occupancy times the size in color space.\n        var pq2 = new PQueue(function(a,b) {\n            return pv.naturalOrder(a.count()*a.volume(), b.count()*b.volume());\n        });\n        while (pq.size()) {\n            pq2.push(pq.pop());\n        }\n\n        // next set - generate the median cuts using the (npix * vol) sorting.\n        iter(pq2, maxcolors - pq2.size());\n\n        // calculate the actual colors\n        var cmap = new CMap();\n        while (pq2.size()) {\n            cmap.push(pq2.pop());\n        }\n\n        return cmap;\n    }\n\n    return {\n        quantize: quantize\n    };\n})();\n\nexport default ColorThief;\n"],"names":["CanvasImage","image","canvas","document","createElement","context","this","getContext","width","height","drawImage","prototype","getPixelCount","getImageData","ColorThief","getColor","sourceImage","quality","getPalette","colorCount","offset","r","g","b","pixels","data","pixelCount","pixelArray","i","push","cmap","MMCQ","quantize","palette","getColorFromUrl","imageUrl","callback","thief","addEventListener","src","xhr","XMLHttpRequest","open","responseType","onload","status","uInt8Array","Uint8Array","response","length","binaryString","Array","String","fromCharCode","join","base64","window","btoa","send","getColorAsync","imageData","pv","map","array","f","o","d","index","call","slice","naturalOrder","a","sum","reduce","p","max","Math","apply","sigbits","rshift","maxIterations","getColorIndex","PQueue","comparator","contents","sorted","sort","peek","undefined","pop","size","debug","VBox","r1","r2","g1","g2","b1","b2","histo","CMap","vboxes","vbox","count","volume","medianCutApply","rw","gw","maxw","copy","j","k","total","partialsum","lookaheadsum","forEach","color","left","right","vbox1","vbox2","d2","dim1","dim2","count2","min","doCut","force","_volume","_count_set","npix","_count","avg","_avg","hval","ntot","mult","rsum","gsum","bsum","contains","pixel","rval","gval","bval","vb","nearest","d1","pColor","sqrt","pow","forcebw","lowest","idx","highest","maxcolors","getHisto","rmin","rmax","gmin","gmax","bmin","bmax","vboxFromPixels","pq","iter","lh","target","ncolors","niters","pq2"],"mappings":"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"}